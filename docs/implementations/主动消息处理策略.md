# 主动消息处理策略实现文档

## 概述

实现了基于策略模式的消息处理系统，支持主动回复和被动回复两种策略。主动回复策略包含体力值系统，实现智能的消息回复频率管理。

## 架构设计

### 核心类结构

```
BaseMessageHandler (抽象基类)
├── PassiveMessageHandler (被动回复策略)
└── ActiveMessageHandler (主动回复策略)
    └── EnergyManager (体力值管理)
```

### 主要组件

#### 1. BaseMessageHandler (`src/base_message_handler.ts`)

**职责**：
- 提供消息处理的公共逻辑
- 管理消息历史记录
- 处理LLM调用和响应解析
- 定义消息处理接口

**核心方法**：
- `processAndReply()`: 统一的消息处理和回复流程（无参数，基于历史消息）
- `buildChatMessages()`: 构建LLM上下文
- `parseResponse()`: 解析LLM JSON数组响应（已移除旧格式兼容）
- `addMessageToHistory()`: 管理消息历史（LRU策略）

#### 2. ActiveMessageHandler (`src/active_message_handler.ts`)

**职责**：
- 实现主动回复策略
- 集成体力值系统
- 防止并发LLM对话重复回复
- 通过消息队列确保顺序处理

**核心逻辑**：
```typescript
async handleMessage(message: Message): Promise<void> {
    // 1. 消息入队
    this.messageQueue.push(message);
    
    // 2. 触发队列处理（如果LLM未在处理中）
    if (!this.isLlmProcessing) {
        await this.processQueueLoop();
    }
}

private async processQueueLoop(): Promise<void> {
    this.isLlmProcessing = true;
    try {
        while (this.messageQueue.length > 0) {
            const message = this.messageQueue.shift();
            // 处理消息：历史记录 -> 体力检查 -> LLM对话 -> 回复
        }
    } finally {
        this.isLlmProcessing = false;
    }
}
```

**并发控制机制**：
- `isLlmProcessing`: 防止并发LLM对话
- `messageQueue`: 缓存等待处理的消息
- while循环: 确保队列中所有消息都被处理

#### 3. EnergyManager (`src/energy_manager.ts`)

**职责**：
- 管理体力值状态
- 实现定时恢复机制
- 提供体力值检查和消耗接口

**核心机制**：
- **消耗**: `consumeEnergy()` - 检查并消耗体力
- **恢复**: 定时器每60秒恢复5点体力（可配置）
- **查询**: `canSendMessage()` - 检查是否有足够体力
- **清理**: `destroy()` - 清理定时器资源

#### 4. PassiveMessageHandler (`src/passive_message_handler.ts`)

**职责**：
- 保持原有@回复逻辑
- 继承BaseMessageHandler获得公共功能
- 作为备选策略保留

## 配置系统

### BehaviorConfig接口

```typescript
export interface BehaviorConfig {
    energy_max: number;              // 体力值上限
    energy_cost: number;             // 每次回复消耗体力
    energy_recovery_rate: number;    // 体力恢复速度（每60秒）
    energy_recovery_interval: number; // 体力恢复间隔（秒）
    message_handler_type: 'active' | 'passive'; // 消息处理策略
}
```

### 默认配置值

- `energy_max`: 100
- `energy_cost`: 1  
- `energy_recovery_rate`: 5
- `energy_recovery_interval`: 60秒
- `message_handler_type`: "active"

## 运行时行为

### 主动回复流程

1. **消息接收**: 所有群消息加入处理队列
2. **队列处理**: 
   - 检查LLM是否处理中，如果空闲则触发处理循环
   - while循环处理队列中的所有消息
3. **单条消息处理**:
   - 添加到历史记录
   - 检查体力值是否足够
   - 消耗体力值
   - 调用LLM生成回复
   - 发送回复或退还体力
4. **并发控制**: 通过`isLlmProcessing`状态确保同时只有一个LLM对话

### 体力值恢复机制

- **定时恢复**: 每60秒检查一次
- **恢复量**: 每次恢复5点体力（可配置）
- **上限控制**: 不会超过最大体力值
- **日志记录**: 记录体力变化情况

### 策略切换

通过修改配置文件的`behavior.message_handler_type`实现：
- `"active"`: 使用主动回复策略
- `"passive"`: 使用传统@回复策略

## 集成点

### SessionManager集成

- 根据配置自动选择消息处理策略
- 管理ActiveMessageHandler的生命周期
- 在关闭时正确清理资源（定时器等）

### 配置文件集成

- 支持yaml配置文件设置所有参数
- 提供合理默认值，缺失配置时自动补充
- 开发和生产环境分别优化默认参数

## 注意事项

1. **资源清理**: ActiveMessageHandler需要在关闭时调用`destroy()`清理定时器
2. **消息历史**: AI消息的role正确设置为`assistant`
3. **体力值日志**: 提供详细的体力值变化日志便于调试
4. **并发安全**: 通过消息队列和状态标志防止并发LLM对话
5. **错误处理**: LLM响应格式错误或解析失败时静默处理，不发送错误消息给用户
6. **队列处理**: 使用while循环确保所有排队消息都被处理完毕