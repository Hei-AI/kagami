# 消息回复功能实现

## 功能概述

实现了完整的 QQ 消息回复功能，支持机器人智能决定何时使用回复引用，以及解析用户发送的回复消息。该功能基于 napcat-qq-ts 的回复消息 API，通过 prompt 优化让 LLM 理解对话对象，避免不必要的回复。

## 核心特性

### 1. 智能回复引用决策
- **自然对话场景**：LLM 不使用回复引用，保持对话的自然流畅
- **问答场景**：LLM 主动使用回复引用，明确回应用户的问题
- **对话对象识别**：通过机器人QQ号上下文和 few shot 示例，准确判断是否应该回复

### 2. 回复消息解析
- **接收解析**：自动检测用户消息中的回复关系
- **关系存储**：在 Message 的 metadata 中记录回复目标消息ID
- **上下文传递**：将回复关系信息传递给 LLM 处理

## 技术实现

### 消息数据结构扩展

```typescript
export interface Message {
    id: string;
    groupId: number;
    userId: number;
    userNickname?: string;
    content: SendMessageSegment[];
    timestamp: Date;
    metadata?: {
        thoughts?: string[];
        hasReply?: boolean;
        replyToMessageId?: string;  // 新增：回复的目标消息ID
    };
}
```

### 回复消息解析 (`src/session.ts`)

```typescript
async handleMessage(context: unknown): Promise<void> {
    // ... 解析基本消息信息

    // 检查消息中是否包含回复
    const replySegment = ctx.message.find(segment => segment.type === "reply");
    const replyToMessageId = replySegment?.data.id;

    const message: Message = {
        id: String(ctx.message_id),
        groupId: ctx.group_id,
        userId: ctx.user_id,
        userNickname,
        content: ctx.message,
        timestamp: new Date(),
        metadata: replyToMessageId ? { replyToMessageId } : undefined,
    };

    // 显示日志包含回复信息
    const replyInfo = replyToMessageId ? ` (回复消息:${replyToMessageId})` : "";
    console.log(`[群 ${String(this.groupId)}] ${userNickname ?? "未知用户"} 发送消息: ${displayContent}${replyInfo}`);
}
```

### 智能回复引用生成 (`src/base_message_handler.ts`)

```typescript
protected buildChatMessages(): ChatCompletionMessageParam[] {
    // 构建包含机器人QQ号的系统提示
    const systemPromptWithContext = `${this.systemPrompt}

<bot_context>
你的QQ号是: ${String(this.botQQ)}
</bot_context>`;

    const messages: ChatCompletionMessageParam[] = [
        { role: "system", content: systemPromptWithContext },
    ];

    // 将完整的消息历史和上下文传递给LLM
    // LLM 可以在 reply 的 content 中自主决定是否包含 reply 段
}

protected async processAndReply(_originalMessage: Message): Promise<boolean> {
    // ... LLM 处理逻辑

    // 直接发送LLM生成的内容，不强制添加回复引用
    if (reply && reply.length > 0) {
        await this.session.sendMessage(reply); // LLM自主决定是否包含reply段
        return true;
    }
    return false;
}
```

## Prompt 优化设计

### 对话对象理解规则

在 `static/prompt.txt` 中添加了详细的指导：

```
<reply_style>
- **对话对象识别**：重要！你需要判断用户是在跟谁说话：
  - 如果用户A在问用户B问题，而不是在问你，你应该保持沉默
  - 只有当消息明确指向你（如@你、回复你的消息）或是在询问群内所有人时才回复
  - 在思考过程中明确分析对话的目标对象

- **回复消息功能使用**：
  - **何时使用回复功能**：当你需要明确指向某条特定消息时才使用
    - 回答用户的具体问题
    - 澄清或纠正某条消息的内容
    - 回应较早的消息（不是最新的）
    - 在多人对话中明确你在回应谁
  - **何时不使用回复功能**：自然对话延续时不需要引用
    - 对最新消息的直接回应
    - 一般性的聊天参与
    - 话题的自然延续
  - **回复消息格式**：在content数组中添加 `{"type": "reply", "data": {"id": "消息ID"}}`
</reply_style>
```

### Few Shot 示例

#### 示例1：不使用回复功能的自然对话
```json
// 用户消息：
{
  "id": "126",
  "userId": 111,
  "userNickname": "小王", 
  "content": [
    {"type": "text", "data": {"text": "今天心情真好！"}}
  ]
}

// 正确的机器人回应（自然延续对话）：
[
  {
    "type": "thought",
    "content": "小王在分享他的心情，这是轻松的聊天"
  },
  {
    "type": "thought",
    "content": "这是自然的对话延续，我可以友好地回应，不需要使用回复功能"
  },
  {
    "type": "reply",
    "content": [
      {"type": "text", "data": {"text": "看起来你今天状态很棒呢！是有什么好事吗？"}}
    ]
  }
]
```

#### 示例2：使用回复功能的问答场景
```json
// 用户消息（技术问题）：
{
  "id": "120",
  "userId": 111,  
  "userNickname": "小王",
  "content": [
    {"type": "text", "data": {"text": "小镜，你知道Python怎么读取文件吗？"}}
  ]
}

// 正确的机器人回应（使用回复功能）：
[
  {
    "type": "thought",
    "content": "小王问了我一个具体的技术问题，我应该回复这条消息让他知道我在回答他"
  },
  {
    "type": "reply",
    "content": [
      {"type": "reply", "data": {"id": "120"}},
      {"type": "text", "data": {"text": "可以用 open() 函数，比如 open('file.txt', 'r') 来读取文件哦～"}}
    ]
  }
]
```

#### 示例3：识别A问B场景，选择不回复
```json
// 用户消息：
{
  "id": "123",
  "userId": 111,
  "userNickname": "小王",
  "content": [
    {"type": "at", "data": {"qq": "222"}},
    {"type": "text", "data": {"text": " 你在做什么？"}}
  ]
}

// 正确的机器人回应（保持沉默）：
[
  {
    "type": "thought",
    "content": "小王在问QQ号222的用户在做什么，不是在问我（QQ号333），这是两个人之间的对话"
  },
  {
    "type": "thought", 
    "content": "我不应该插入到他们的私人对话中，应该保持沉默"
  }
]
```

## 消息流程

### 接收回复消息流程
1. **napcat 事件接收**：接收到包含 reply 段的群消息
2. **Session 解析**：提取 reply 段中的目标消息ID
3. **Message 构建**：将回复关系存储到 metadata.replyToMessageId
4. **日志显示**：在控制台显示回复关系信息
5. **LLM 处理**：将完整上下文传递给 LLM

### 发送回复消息流程
1. **LLM 思考**：基于上下文和机器人QQ号判断对话对象
2. **回复决策**：决定是自然回应还是问答回复
3. **内容生成**：
   - **自然对话**：只包含文本内容
   - **问答场景**：包含 reply 段 + 回答内容
4. **消息发送**：直接发送 LLM 生成的完整内容

## 关键优势

### 1. 智能化回复策略
- **上下文感知**：基于机器人QQ号准确判断是否被询问
- **场景区分**：自动区分闲聊和问答场景
- **自然交互**：避免过度使用回复引用破坏对话流畅性

### 2. 完整的回复生态
- **双向支持**：既能解析用户的回复，也能智能发送回复
- **关系追踪**：完整记录消息间的引用关系
- **上下文传递**：为 LLM 提供丰富的对话上下文

### 3. 灵活的控制机制
- **Prompt 可调**：通过修改 prompt 调整回复策略
- **示例驱动**：通过 few shot 示例教会特定行为
- **类型安全**：基于 TypeScript 确保数据结构正确

## 使用场景

### 适合使用回复引用的场景
- 回答用户的具体问题
- 澄清某条消息的内容  
- 回应较早的消息（避免混淆）
- 多人对话中明确回应对象

### 不使用回复引用的场景
- 对最新消息的自然回应
- 一般性闲聊和话题延续
- 表达情感和观点
- 轻松的群聊参与

## 配置要求

### 必需配置
```yaml
napcat:
  bot_qq: 123456789  # 机器人QQ号，用于对话对象判断
```

### Prompt 文件
- 确保 `static/prompt.txt` 包含完整的回复功能指导
- 包含 few shot 示例和使用规则
- 定义清晰的对话对象识别策略

## 监控和调试

### 日志输出
```
[群 123456] 小王(111) 发送消息: Python怎么读文件？ (回复消息:120)
[群 123456] LLM 思考:
  1. 小王问了我一个具体的技术问题
  2. 我应该回复这条消息让他知道我在回答他
[群 123456] LLM 回复成功: [回复:120]可以用 open() 函数...
```

### 回复关系追踪
- Message.metadata.replyToMessageId 记录回复关系
- 控制台日志显示回复信息
- LLM 可以在思考过程中分析回复上下文

## 扩展性

### 未来可扩展功能
1. **回复链分析**：追踪完整的消息回复链
2. **智能引用推荐**：基于时间和相关性推荐回复目标
3. **回复统计**：分析回复使用情况和效果
4. **多级回复**：支持回复回复的复杂引用关系

### 配置灵活性
- 可通过 prompt 调整回复策略
- Few shot 示例可以根据群组特点定制
- 回复使用频率可通过思考引导控制