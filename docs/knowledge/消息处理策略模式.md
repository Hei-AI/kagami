# 消息处理策略模式知识文档

## 设计模式应用

### 策略模式 (Strategy Pattern)

在Kagami项目中，我们使用策略模式来处理不同的消息回复策略：

```typescript
// 策略接口
interface MessageHandler {
    handleMessage(message: Message): Promise<void>;
}

// 具体策略
class PassiveMessageHandler extends BaseMessageHandler // 被动策略
class ActiveMessageHandler extends BaseMessageHandler  // 主动策略

// 上下文
class SessionManager {
    // 根据配置选择策略
    if (config.message_handler_type === 'active') {
        handler = new ActiveMessageHandler(...)
    } else {
        handler = new PassiveMessageHandler(...)
    }
}
```

**优势**：
- 策略间独立，易于维护和扩展
- 支持运行时策略切换
- 代码职责清晰分离

## 体力值系统设计

### 设计理念

体力值系统模拟人类的精力管理，防止机器人过度活跃：

- **消耗机制**: 每次回复消耗固定体力
- **恢复机制**: 随时间自动恢复
- **限制机制**: 体力不足时拒绝回复

### 实现细节

```typescript
class EnergyManager {
    private currentEnergy: number;     // 当前体力值
    private maxEnergy: number;         // 体力上限
    private costPerMessage: number;    // 每条消息消耗
    private recoveryRate: number;      // 恢复速度
    private recoveryTimer: NodeJS.Timeout; // 恢复定时器
}
```

**关键设计决策**：
- 使用定时器实现恢复机制而非按需计算，保证实时性
- 提供详细日志便于调试和监控
- 支持资源清理避免内存泄漏

## 时间间隔控制

### 防刷屏机制

通过最小回复间隔防止消息刷屏：

```typescript
private canReply(): boolean {
    const timeSinceLastReply = Date.now() - this.lastReplyTime;
    return timeSinceLastReply >= this.minReplyInterval;
}
```

**设计考量**：
- 使用毫秒级精度确保准确控制
- 每个群组独立计时
- 结合体力值系统双重限制

## 消息历史管理

### LRU策略

使用最近最少使用(LRU)策略管理消息历史：

```typescript
private addMessageToHistory(message: Message): void {
    this.messageHistory.push(message);
    if (this.messageHistory.length > this.maxHistorySize) {
        this.messageHistory.shift(); // 移除最旧消息
    }
}
```

### 上下文构建

正确设置OpenAI消息角色：
- 用户消息: `role: "user"`
- AI回复: `role: "assistant"`
- 系统提示: `role: "system"`

## 配置驱动设计

### 可配置参数

所有行为参数均支持配置文件定制：

```yaml
behavior:
  min_reply_interval: 5    # 回复间隔
  energy_max: 100          # 体力上限  
  energy_cost: 1           # 消耗体力
  energy_recovery_rate: 5  # 恢复速度
  energy_recovery_interval: 60 # 恢复间隔
  message_handler_type: "active" # 策略选择
```

### 默认值策略

- 开发环境: 较短间隔，便于测试
- 生产环境: 较长间隔，更保守的策略
- 优雅降级: 缺失配置时使用合理默认值

## 最佳实践

### 1. 资源管理
- 定时器使用后必须清理
- 实现`destroy()`方法释放资源
- 在SessionManager关闭时调用清理

### 2. 错误处理
- 保持原有错误处理机制
- 体力值不足时优雅降级
- 提供详细的调试日志

### 3. 扩展性
- 基类设计便于添加新策略
- 配置项支持热重载
- 独立的组件设计便于测试

### 4. 性能考量
- 避免频繁的时间计算
- 使用Map数据结构提高查找效率
- 合理的消息历史大小限制